import { toHex, } from "viem";
import { ChainNotFoundError } from "../errors/client.js";
import { deepHexlify, resolveProperties, } from "../utils/index.js";
/**
 * Middleware function for interacting with ERC-7677 enabled clients. It supports resolving paymaster and data fields for user operations.
 * This middleware assumes that your RPC provider supports the ERC-7677 methods (pm_getPaymasterStubData and pm_getPaymasterData).
 *
 * @example
 * ```ts
 * import { createSmartAccountClient, erc7677Middleware } from "@aa-sdk/core";
 * import { http } from "viem";
 * import { sepolia } from "viem/chains";
 *
 * const client = createSmartAccountClient({
 *  transport: http("rpc-url"),
 *  chain: sepolia,
 *  // this assumes that your RPC provider supports the ERC-7677 methods AND takes no context
 *  ...erc7677Middleware(),
 * })
 * ```
 *
 * @param {Erc7677MiddlewareParams<TContext>} params Middleware parameters including context function or object. Context can be resolved dynamically by passing in a function which takes in the context at the time of sending a user op
 * @returns {Pick<ClientMiddlewareConfig, "dummyPaymasterAndData" | "paymasterAndData">} An object containing middleware functions `dummyPaymasterAndData` and `paymasterAndData` for processing user operations with the paymaster data
 */
export function erc7677Middleware(params) {
    const dummyPaymasterAndData = async (uo, { client, account, feeOptions, overrides }) => {
        const userOp = deepHexlify(await resolveProperties(uo));
        // Those values will be set after fee estimation.
        userOp.maxFeePerGas = "0x0";
        userOp.maxPriorityFeePerGas = "0x0";
        userOp.callGasLimit = "0x0";
        userOp.verificationGasLimit = "0x0";
        userOp.preVerificationGas = "0x0";
        const entrypoint = account.getEntryPoint();
        if (entrypoint.version === "0.7.0") {
            userOp.paymasterVerificationGasLimit = "0x0";
            userOp.paymasterPostOpGasLimit = "0x0";
        }
        const context = (typeof params?.context === "function"
            ? await params?.context(userOp, { overrides, feeOptions })
            : params?.context) ?? {};
        if (!client.chain) {
            throw new ChainNotFoundError();
        }
        const erc7677client = client;
        // TODO: probably need to handle the sponsor and isFinal fields
        const { paymaster, paymasterAndData, paymasterData, paymasterPostOpGasLimit, paymasterVerificationGasLimit, } = await erc7677client.request({
            method: "pm_getPaymasterStubData",
            params: [userOp, entrypoint.address, toHex(client.chain.id), context],
        });
        if (entrypoint.version === "0.6.0") {
            return {
                ...uo,
                paymasterAndData,
            };
        }
        return {
            ...uo,
            paymaster,
            paymasterData,
            paymasterPostOpGasLimit,
            paymasterVerificationGasLimit,
        };
    };
    const paymasterAndData = async (uo, { client, account, feeOptions, overrides }) => {
        const userOp = deepHexlify(await resolveProperties(uo));
        const context = (typeof params?.context === "function"
            ? await params?.context(userOp, { overrides, feeOptions })
            : params?.context) ?? {};
        if (!client.chain) {
            throw new ChainNotFoundError();
        }
        const erc7677client = client;
        const entrypoint = account.getEntryPoint();
        const { paymaster, paymasterAndData, paymasterData } = await erc7677client.request({
            method: "pm_getPaymasterData",
            params: [userOp, entrypoint.address, toHex(client.chain.id), context],
        });
        if (entrypoint.version === "0.6.0") {
            return {
                ...uo,
                paymasterAndData,
            };
        }
        return {
            ...uo,
            paymaster,
            paymasterData,
        };
    };
    return {
        dummyPaymasterAndData,
        paymasterAndData,
    };
}
//# sourceMappingURL=erc7677middleware.js.map