import { custom, } from "viem";
import { z } from "zod";
import { AccountNotFoundError } from "../errors/account.js";
import { ChainNotFoundError } from "../errors/client.js";
import { middlewareActions } from "../middleware/actions.js";
import { createBundlerClient } from "./bundlerClient.js";
import {} from "./decorators/bundlerClient.js";
import { smartAccountClientActions, } from "./decorators/smartAccountClient.js";
import { SmartAccountClientOptsSchema } from "./schema.js";
/**
 * Creates a smart account client using the provided configuration. This client handles various Ethereum transactions and message signing operations.
 *
 * @example
 * ```ts
 * import { createSmartAccountClient, toSmartContractAccount } from "@aa-sdk/core";
 * import { http } from "viem";
 * import { sepolia } from "viem/chains";
 *
 * const client = createSmartAccountClient({
 *  chain: sepolia,
 *  transport: http("RPC_URL"),
 *  // optionally hoist the account
 *  account: toSmartContractAccount(...),
 * });
 * ```
 *
 * @param {SmartAccountClientConfig} config The configuration for creating the smart account client
 * @returns {SmartAccountClient} A smart account client capable of handling transactions, message signing, and other operations on a smart account
 */
export function createSmartAccountClient(config) {
    const { key = "account", name = "account provider", transport, type = "SmartAccountClient", ...params } = config;
    const client = createBundlerClient({
        ...params,
        key,
        name,
        // we start out with this because the base methods for a SmartAccountClient
        // require a smart account client, but once we have completed building everything
        // we want to override this value with the one passed in by the extender
        type: "SmartAccountClient",
        // TODO: this needs to be tested
        transport: (opts) => {
            const rpcTransport = transport(opts);
            return custom({
                async request({ method, params }) {
                    switch (method) {
                        case "eth_accounts": {
                            if (!client.account) {
                                throw new AccountNotFoundError();
                            }
                            return [client.account.address];
                        }
                        case "eth_sendTransaction":
                            if (!client.account) {
                                throw new AccountNotFoundError();
                            }
                            if (!client.chain) {
                                throw new ChainNotFoundError();
                            }
                            const [tx] = params;
                            return client.sendTransaction({
                                ...tx,
                                account: client.account,
                                chain: client.chain,
                            });
                        case "eth_sign":
                            if (!client.account) {
                                throw new AccountNotFoundError();
                            }
                            const [address, data] = params;
                            if (address !== client.account.address) {
                                throw new Error("cannot sign for address that is not the current account");
                            }
                            return client.signMessage(data);
                        case "personal_sign": {
                            if (!client.account) {
                                throw new AccountNotFoundError();
                            }
                            const [data, address] = params;
                            if (address !== client.account.address) {
                                throw new Error("cannot sign for address that is not the current account");
                            }
                            return client.signMessage(data);
                        }
                        case "eth_signTypedData_v4": {
                            if (!client.account) {
                                throw new AccountNotFoundError();
                            }
                            const [address, dataParams] = params;
                            if (address !== client.account.address) {
                                throw new Error("cannot sign for address that is not the current account");
                            }
                            return client.signTypedData(dataParams);
                        }
                        case "eth_chainId":
                            if (!opts.chain) {
                                throw new ChainNotFoundError();
                            }
                            return opts.chain.id;
                        default:
                            // TODO: there's probably a number of methods we just don't support, will need to test most of them out
                            // first let's get something working though
                            return rpcTransport.request({ method, params });
                    }
                },
            })(opts);
        },
    })
        .extend(() => ({
        ...SmartAccountClientOptsSchema.parse(config.opts ?? {}),
    }))
        .extend(middlewareActions(config))
        .extend(smartAccountClientActions);
    return { ...client, type };
}
/**
 * Creates a smart account client using an existing client and specific configuration. This function can be used to reuse a pre-existing BundlerClient while customizing other aspects of the smart account.
 *
 * @example
 * ```ts
 * import {
 *   createBundlerClient,
 *   createSmartAccountClientFromExisting,
 *   toSmartContractAccount
 * } from "@aa-sdk/core";
 *
 * const bundlerClient = createBundlerClient(...);
 * const client = createSmartAccountClientFromExisting({
 *  client,
 *  account: toSmartContractAccount(...),
 * })
 * ```
 *
 * @param {Omit<SmartAccountClientConfig, "transport" | "chain"> & {client: BundlerClient}} config the configuration object which includes the client
 * @returns {SmartAccountClient} A smart account client created from the existing BundlerClient
 */
export function createSmartAccountClientFromExisting(config) {
    return createSmartAccountClient({
        ...config,
        chain: config.client.chain,
        transport: custom(config.client),
    });
}
//# sourceMappingURL=smartAccountClient.js.map