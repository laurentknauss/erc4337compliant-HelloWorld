import { type Hex } from "viem";
import type { EntryPointVersion } from "../entrypoint/types";
import type { BigNumberish, Multiplier, UserOperationFeeOptionsField, UserOperationOverrides, UserOperationRequest, UserOperationStruct } from "../types";
/**
 * Utility method for asserting a UserOperationStruct has valid fields for the given entry point version
 *
 * @param {UserOperationStruct} request a UserOperationStruct to validate
 * @returns {boolean} a type guard that asserts the UserOperationRequest is valid
 */
export declare function isValidRequest<TEntryPointVersion extends EntryPointVersion = EntryPointVersion>(request: UserOperationStruct<TEntryPointVersion>): request is UserOperationRequest<TEntryPointVersion>;
/**
 * Utility method for asserting a UserOperationRequest has valid fields for the paymaster data
 *
 * @param {UserOperationRequest} request a UserOperationRequest to validate
 * @returns {boolean}  a type guard that asserts the UserOperationRequest is a UserOperationRequest
 */
export declare function isValidPaymasterAndData<TEntryPointVersion extends EntryPointVersion = EntryPointVersion>(request: UserOperationStruct<TEntryPointVersion>): boolean;
/**
 * Utility method for asserting a UserOperationStruct has valid fields for the paymaster data
 *
 * @param {UserOperationRequest} request a UserOperationRequest to validate
 * @returns {boolean} a type guard that asserts the UserOperationStruct is a UserOperationRequest
 */
export declare function isValidFactoryAndData<TEntryPointVersion extends EntryPointVersion = EntryPointVersion>(request: UserOperationStruct<TEntryPointVersion>): boolean;
/**
 * Utility method for applying a UserOperationOverrides field value
 * over the current value set for the field
 *
 * @param {BigNumberish} value the current value of the field
 * @param {BigNumberish | Multiplier} override the override value to apply
 * @returns {BigNumberish} the new value of the field after applying the override
 */
export declare function applyUserOpOverride<TValue extends BigNumberish | undefined>(value: TValue, override?: BigNumberish | Multiplier): TValue | BigNumberish;
/**
 * Utility method for applying a UserOperationFeeOptionsField value
 * over the current value set for the field
 *
 * @param {BigNumberish} value the current value of the field
 * @param {UserOperationFeeOptionsField} feeOption the override value to apply
 * @returns {BigNumberish} the new value of the field after applying the override
 */
export declare function applyUserOpFeeOption<TValue extends BigNumberish | undefined>(value: TValue, feeOption?: UserOperationFeeOptionsField): TValue | BigNumberish;
/**
 * Utility method for applying a UserOperationOverrides field value and
 * a UserOperationFeeOptionsField value over the current value set for the field,
 * with the override taking precedence over the fee option
 *
 * @param {BigNumberish} value the current value of the field
 * @param {BigNumberish | Multiplier} [override] the override value to apply
 * @param {UserOperationFeeOptionsField} [feeOption] the fee option field value to apply
 * @returns {BigNumberish} the new value of the field after applying the override or fee option
 */
export declare function applyUserOpOverrideOrFeeOption<TValue extends BigNumberish | undefined>(value: TValue, override?: BigNumberish | Multiplier, feeOption?: UserOperationFeeOptionsField): TValue | BigNumberish;
/**
 * Utility method for checking whether the middleware pipeline should
 * bypass the paymaster middleware for the user operation with the given overrides,
 * either because the UserOp is paying for its own gas, or passing a specific paymaster
 *
 * @template EntryPointVersion TEntryPointVersion
 * @param {UserOperationOverrides<TEntryPointVersion> | undefined} overrides the user operation overrides to check
 * @returns {boolean} whether the paymaster middleware should be bypassed
 */
export declare const bypassPaymasterAndData: <TEntryPointVersion extends keyof import("../entrypoint/types").EntryPointRegistryBase<unknown> = keyof import("../entrypoint/types").EntryPointRegistryBase<unknown>>(overrides: Partial<{
    callGasLimit: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["callGasLimit"];
    maxFeePerGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["maxFeePerGas"];
    maxPriorityFeePerGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["maxPriorityFeePerGas"];
    preVerificationGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["preVerificationGas"];
    verificationGasLimit: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["verificationGasLimit"];
    nonceKey: bigint;
    stateOverride: import("viem").StateOverride;
} & import("../types").UserOperationPaymasterOverrides<TEntryPointVersion>> | undefined) => boolean;
/**
 * An alternative to `bypassPaymasterAndData` which only returns true if the data parameter
 * is "0x," this is useful for cases when middleware should be bypassed ONLY IF the UserOp will
 * pay for its own gas
 *
 * @template EntryPointVersion TEntryPointVersion
 * @param {UserOperationOverrides<TEntryPointVersion> | undefined} overrides the user operation overrides to check
 * @returns {boolean} whether the paymaster middleware should be bypassed
 */
export declare const bypassPaymasterAndDataEmptyHex: <TEntryPointVersion extends keyof import("../entrypoint/types").EntryPointRegistryBase<unknown> = keyof import("../entrypoint/types").EntryPointRegistryBase<unknown>>(overrides: Partial<{
    callGasLimit: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["callGasLimit"];
    maxFeePerGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["maxFeePerGas"];
    maxPriorityFeePerGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["maxPriorityFeePerGas"];
    preVerificationGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["preVerificationGas"];
    verificationGasLimit: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["verificationGasLimit"];
    nonceKey: bigint;
    stateOverride: import("viem").StateOverride;
} & import("../types").UserOperationPaymasterOverrides<TEntryPointVersion>> | undefined) => boolean;
/**
 * Utility method for parsing the paymaster address and paymasterData from the paymasterAndData hex string
 *
 * @param {Hex} paymasterAndData the paymaster and data hex string to parse.
 *                         The hex string refers to the paymasterAndData field of entrypoint v0.6 user operation request
 * @returns {{ paymaster: Hex; paymasterData: Hex}} the parsed paymaster and paymasterData fields of entrypoint v0.7 user operation request paymaster and paymasterData field
 */
export declare const parsePaymasterAndData: (paymasterAndData: Hex) => Pick<UserOperationRequest<"0.7.0">, "paymaster" | "paymasterData">;
/**
 * Utility method for converting the object containing the paymaster address and paymaster data
 * to the paymaster and data concatenated hex string
 *
 * @param {{ paymaster: Hex; paymasterData: Hex}} paymasterAndData the object containing the picked paymaster and paymasterData fields of
 *                         entrypoint v0.7 user operation request
 * @param {Hex} paymasterAndData.paymaster the paymaster address
 * @param {Hex} paymasterAndData.paymasterData the paymaster data
 * @returns {Hex} the paymasterAndData hex value of entrypoint v0.6 user operation request paymasterAndData field
 */
export declare const concatPaymasterAndData: ({ paymaster, paymasterData, }: Pick<UserOperationRequest<"0.7.0">, "paymaster" | "paymasterData">) => Hex;
//# sourceMappingURL=userop.d.ts.map