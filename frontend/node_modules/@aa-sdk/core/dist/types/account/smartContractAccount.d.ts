import { type Address, type Chain, type CustomSource, type Hex, type LocalAccount, type PublicClient, type SignableMessage, type Transport, type TypedData, type TypedDataDefinition } from "viem";
import type { EntryPointDef, EntryPointRegistryBase, EntryPointVersion } from "../entrypoint/types.js";
import type { SmartAccountSigner } from "../signer/types.js";
import type { NullAddress } from "../types.js";
import type { IsUndefined } from "../utils/types.js";
export type AccountOp = {
    target: Address;
    value?: bigint;
    data: Hex | "0x";
};
export declare enum DeploymentState {
    UNDEFINED = "0x0",
    NOT_DEPLOYED = "0x1",
    DEPLOYED = "0x2"
}
export type GetEntryPointFromAccount<TAccount extends SmartContractAccount | undefined, TAccountOverride extends SmartContractAccount = SmartContractAccount> = GetAccountParameter<TAccount, TAccountOverride> extends SmartContractAccount<string, infer TEntryPointVersion> ? TEntryPointVersion : EntryPointVersion;
export type GetAccountParameter<TAccount extends SmartContractAccount | undefined = SmartContractAccount | undefined, TAccountOverride extends SmartContractAccount = SmartContractAccount> = IsUndefined<TAccount> extends true ? {
    account: TAccountOverride;
} : {
    account?: TAccountOverride;
};
export type UpgradeToAndCallParams = {
    upgradeToAddress: Address;
    upgradeToInitData: Hex;
};
export type SmartContractAccountWithSigner<Name extends string = string, TSigner extends SmartAccountSigner = SmartAccountSigner, TEntryPointVersion extends EntryPointVersion = EntryPointVersion> = SmartContractAccount<Name, TEntryPointVersion> & {
    getSigner: () => TSigner;
};
/**
 * Determines if the given SmartContractAccount has a signer associated with it.
 *
 * @example
 * ```ts
 * import { toSmartContractAccount } from "@aa-sdk/core";
 *
 * const account = await toSmartContractAccount(...);
 *
 * console.log(isSmartAccountWithSigner(account)); // false: the base account does not have a publicly accessible signer
 * ```
 *
 * @param {SmartContractAccount} account The account to check.
 * @returns {boolean} true if the account has a signer, otherwise false.
 */
export declare const isSmartAccountWithSigner: (account: SmartContractAccount) => account is SmartContractAccountWithSigner<string, SmartAccountSigner<any>, keyof EntryPointRegistryBase<unknown>>;
export type SmartContractAccount<Name extends string = string, TEntryPointVersion extends EntryPointVersion = EntryPointVersion> = LocalAccount<Name> & {
    source: Name;
    getDummySignature: () => Hex | Promise<Hex>;
    encodeExecute: (tx: AccountOp) => Promise<Hex>;
    encodeBatchExecute: (txs: AccountOp[]) => Promise<Hex>;
    signUserOperationHash: (uoHash: Hex) => Promise<Hex>;
    signMessageWith6492: (params: {
        message: SignableMessage;
    }) => Promise<Hex>;
    signTypedDataWith6492: <const typedData extends TypedData | Record<string, unknown>, primaryType extends keyof typedData | "EIP712Domain" = keyof typedData>(typedDataDefinition: TypedDataDefinition<typedData, primaryType>) => Promise<Hex>;
    encodeUpgradeToAndCall: (params: UpgradeToAndCallParams) => Promise<Hex>;
    getAccountNonce(nonceKey?: bigint): Promise<bigint>;
    getInitCode: () => Promise<Hex>;
    isAccountDeployed: () => Promise<boolean>;
    getFactoryAddress: () => Promise<Address>;
    getFactoryData: () => Promise<Hex>;
    getEntryPoint: () => EntryPointDef<TEntryPointVersion>;
    getImplementationAddress: () => Promise<NullAddress | Address>;
};
export interface AccountEntryPointRegistry<Name extends string = string> extends EntryPointRegistryBase<SmartContractAccount<Name, EntryPointVersion>> {
    "0.6.0": SmartContractAccount<Name, "0.6.0">;
    "0.7.0": SmartContractAccount<Name, "0.7.0">;
}
export type ToSmartContractAccountParams<Name extends string = string, TTransport extends Transport = Transport, TChain extends Chain = Chain, TEntryPointVersion extends EntryPointVersion = EntryPointVersion> = {
    source: Name;
    transport: TTransport;
    chain: TChain;
    entryPoint: EntryPointDef<TEntryPointVersion, TChain>;
    accountAddress?: Address;
    getAccountInitCode: () => Promise<Hex>;
    getDummySignature: () => Hex | Promise<Hex>;
    encodeExecute: (tx: AccountOp) => Promise<Hex>;
    encodeBatchExecute?: (txs: AccountOp[]) => Promise<Hex>;
    signUserOperationHash?: (uoHash: Hex) => Promise<Hex>;
    encodeUpgradeToAndCall?: (params: UpgradeToAndCallParams) => Promise<Hex>;
} & Omit<CustomSource, "signTransaction" | "address">;
/**
 * Parses the factory address and factory calldata from the provided account initialization code (initCode).
 *
 * @example
 * ```ts
 * import { parseFactoryAddressFromAccountInitCode } from "@aa-sdk/core";
 *
 * const [address, calldata] = parseFactoryAddressFromAccountInitCode("0xAddressCalldata");
 * ```
 *
 * @param {Hex} initCode The initialization code from which to parse the factory address and calldata
 * @returns {[Address, Hex]} A tuple containing the parsed factory address and factory calldata
 */
export declare const parseFactoryAddressFromAccountInitCode: (initCode: Hex) => [Address, Hex];
export type GetAccountAddressParams = {
    client: PublicClient;
    entryPoint: EntryPointDef;
    accountAddress?: Address;
    getAccountInitCode: () => Promise<Hex>;
};
/**
 * Retrieves the account address. Uses a provided `accountAddress` if available; otherwise, it computes the address using the entry point contract and the initial code.
 *
 * @example
 * ```ts
 * import { getEntryPoint, getAccountAddress } from "@aa-sdk/core";
 *
 * const accountAddress = await getAccountAddress({
 *  client,
 *  entryPoint: getEntryPoint(chain),
 *  getAccountInitCode: async () => "0x{factoryAddress}{factoryCallData}",
 * });
 * ```
 *
 * @param {GetAccountAddressParams} params The configuration object
 * @param {PublicClient} params.client A public client instance to interact with the blockchain
 * @param {EntryPointDef} params.entryPoint The entry point definition which includes the address and ABI
 * @param {Address} params.accountAddress Optional existing account address
 * @param {() => Promise<Hex>} params.getAccountInitCode A function that returns a Promise resolving to a Hex string representing the initial code of the account
 * @returns {Promise<Address>} A promise that resolves to the account address
 */
export declare const getAccountAddress: ({ client, entryPoint, accountAddress, getAccountInitCode, }: GetAccountAddressParams) => Promise<`0x${string}`>;
export declare function toSmartContractAccount<Name extends string = string, TTransport extends Transport = Transport, TChain extends Chain = Chain, TEntryPointVersion extends EntryPointVersion = EntryPointVersion>({ transport, chain, entryPoint, source, accountAddress, getAccountInitCode, signMessage, signTypedData, encodeBatchExecute, encodeExecute, getDummySignature, signUserOperationHash, encodeUpgradeToAndCall, }: ToSmartContractAccountParams<Name, TTransport, TChain, TEntryPointVersion>): Promise<SmartContractAccount<Name, TEntryPointVersion>>;
//# sourceMappingURL=smartContractAccount.d.ts.map