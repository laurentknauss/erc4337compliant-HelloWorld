import { hashMessage, hashTypedData, } from "viem";
import { MultisigPlugin, MultisigPluginAbi } from "./plugin.js";
export const multisigSignMethods = ({ client, accountAddress, signer, threshold, pluginAddress = MultisigPlugin.meta.addresses[client.chain.id], }) => {
    const signWith712Wrapper = async (msg) => {
        const [, name, version, chainId, verifyingContract, salt] = await client.readContract({
            abi: MultisigPluginAbi,
            address: pluginAddress,
            functionName: "eip712Domain",
            account: accountAddress,
        });
        return signer().signTypedData({
            domain: {
                chainId: Number(chainId),
                name,
                salt,
                verifyingContract,
                version,
            },
            types: {
                AlchemyMultisigMessage: [{ name: "message", type: "bytes" }],
            },
            message: {
                message: msg,
            },
            primaryType: "AlchemyMultisigMessage",
        });
    };
    return {
        getDummySignature: async () => {
            const [, thresholdRead] = await client.readContract({
                abi: MultisigPluginAbi,
                address: pluginAddress,
                functionName: "ownershipInfoOf",
                args: [accountAddress],
            });
            const actualThreshold = thresholdRead === 0n ? threshold : thresholdRead;
            // (uint upperLimitPreVerificationGas, uint upperLimitMaxFeePerGas, uint upperLimitMaxPriorityFeePerGas)
            // the first sig will be on "actual" with v = 32
            return ("0x" +
                "FF".repeat(32 * 3) +
                "fffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3c" +
                "fffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c".repeat(Number(actualThreshold) - 1));
        },
        signUserOperationHash: (uoHash) => {
            return signer().signMessage({ raw: uoHash });
        },
        signMessage({ message }) {
            return signWith712Wrapper(hashMessage(message));
        },
        signTypedData: (typedDataDefinition) => {
            return signWith712Wrapper(hashTypedData(typedDataDefinition));
        },
    };
};
//# sourceMappingURL=signer.js.map