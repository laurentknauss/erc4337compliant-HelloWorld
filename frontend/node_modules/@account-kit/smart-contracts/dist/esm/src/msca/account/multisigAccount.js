import { createBundlerClient, getAccountAddress, getEntryPoint, toSmartContractAccount, } from "@aa-sdk/core";
import { concatHex, encodeFunctionData, hexToBigInt, } from "viem";
import { MultisigModularAccountFactoryAbi } from "../abis/MultisigModularAccountFactory.js";
import { multisigSignMethods } from "../plugins/multisig/signer.js";
import { getDefaultMultisigModularAccountFactoryAddress } from "../utils.js";
import { standardExecutor } from "./standardExecutor.js";
export const MULTISIG_ACCOUNT_SOURCE = "MultisigModularAccount";
/**
 * Creates a multisig modular account using the provided parameters, including transport, chain, signer, account address, and other account settings. It configures the account with multiple owners and the specified threshold.
 *
 * @example
 * ```ts
 * import { createMultisigModularAccount } from "@account-kit/smart-contracts";
 * import { LocalAccountSigner } from "@aa-sdk/core";
 * import { sepolia } from "viem/chains";
 * import { http, generatePrivateKey } from "viem"
 *
 * const account = await createMultisigModularAccount({
 *  chain: sepolia,
 *  transport: http("RPC_URL"),
 *  signer: LocalAccountSigner.privateKeyToAccountSigner(generatePrivateKey()),
 *  owners: [...], // other owners on the account
 *  threshold: 2, // 2 of N signatures
 * });
 * ```
 *
 * @param {CreateMultisigModularAccountParams} config The parameters for creating a multisig modular account.
 * @returns {Promise<MultisigModularAccount>} A promise that resolves to a `MultisigModularAccount` object containing the created account information and methods.
 */
export async function createMultisigModularAccount(config) {
    const { transport, chain, signer, accountAddress: accountAddress_, initCode, entryPoint = getEntryPoint(chain, { version: "0.6.0" }), factoryAddress = getDefaultMultisigModularAccountFactoryAddress(chain), owners = [], salt = 0n, threshold, } = config;
    const client = createBundlerClient({
        transport,
        chain,
    });
    const getAccountInitCode = async () => {
        if (initCode) {
            return initCode;
        }
        // NOTE: the current signer connected will be one of the sigs as well
        const sigAddress = await signer.getAddress();
        // sigs need to be deduped + ordered in ascending order and !== to zero address
        const sigs_ = Array.from(new Set([...owners, sigAddress]))
            .filter((x) => hexToBigInt(x) !== 0n)
            .sort((a, b) => {
            const bigintA = hexToBigInt(a);
            const bigintB = hexToBigInt(b);
            return bigintA < bigintB ? -1 : bigintA > bigintB ? 1 : 0;
        });
        return concatHex([
            factoryAddress,
            encodeFunctionData({
                abi: MultisigModularAccountFactoryAbi,
                functionName: "createAccount",
                args: [salt, sigs_, threshold],
            }),
        ]);
    };
    const accountAddress = await getAccountAddress({
        client,
        entryPoint,
        accountAddress: accountAddress_,
        getAccountInitCode,
    });
    const baseAccount = await toSmartContractAccount({
        transport,
        chain,
        entryPoint,
        accountAddress,
        source: MULTISIG_ACCOUNT_SOURCE,
        getAccountInitCode,
        ...standardExecutor,
        ...multisigSignMethods({
            client,
            accountAddress,
            threshold,
            signer: () => signer,
        }),
    });
    return {
        ...baseAccount,
        getLocalThreshold: () => threshold,
        publicKey: await signer.getAddress(),
        getSigner: () => signer,
    };
}
export const isMultisigModularAccount = (acct) => {
    return acct.source === MULTISIG_ACCOUNT_SOURCE;
};
//# sourceMappingURL=multisigAccount.js.map