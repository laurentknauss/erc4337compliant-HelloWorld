{"version":3,"file":"signMultisigUserOperation.js","sourceRoot":"","sources":["../../../../../../../src/msca/plugins/multisig/actions/signMultisigUserOperation.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,oBAAoB,EACpB,uBAAuB,EACvB,mCAAmC,EACnC,oBAAoB,EACpB,wBAAwB,GAEzB,MAAM,cAAc,CAAC;AACtB,OAAO,EAA2C,MAAM,MAAM,CAAC;AAC/D,OAAO,EAAE,6BAA6B,EAAE,MAAM,oBAAoB,CAAC;AACnE,OAAO,EAGN,MAAM,aAAa,CAAC;AACrB,OAAO,EAAE,iBAAiB,EAAE,wBAAwB,EAAE,MAAM,mBAAmB,CAAC;AAEhF,MAAM,CAAC,KAAK,UAAU,yBAAyB,CAO7C,MAA4C,EAC5C,MAAiD;IAEjD,MAAM,EAAE,OAAO,GAAG,MAAM,CAAC,OAAO,EAAE,UAAU,EAAE,oBAAoB,EAAE,GAAG,MAAM,CAAC;IAE9E,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,MAAM,IAAI,oBAAoB,EAAE,CAAC;IACnC,CAAC;IAED,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,EAAE,CAAC;QAClC,MAAM,IAAI,uBAAuB,CAC/B,oBAAoB,EACpB,2BAA2B,EAC3B,MAAM,CACP,CAAC;IACJ,CAAC;IAED,IAAI,CAAC,wBAAwB,CAAC,OAAO,CAAC,EAAE,CAAC;QACvC,MAAM,IAAI,mCAAmC,EAAE,CAAC;IAClD,CAAC;IAED,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;QACvB,MAAM,IAAI,6BAA6B,EAAE,CAAC;IAC5C,CAAC;IAED,MAAM,aAAa,GAAG,MAAM,OAAO,CAAC,SAAS,EAAE,CAAC,UAAU,EAAE,CAAC;IAE7D,MAAM,aAAa,GAAG,MAAM,MAAM,CAAC,iBAAiB,CAAC;QACnD,OAAO;QACP,QAAQ,EAAE,oBAAoB;QAC9B,OAAO,EAAE;YACP,mBAAmB,EAAE,iBAAiB,CAAC;gBACrC,UAAU;gBACV,sBAAsB,EAAE,oBAAoB,CAAC,YAAY;gBACzD,8BAA8B,EAC5B,oBAAoB,CAAC,oBAAoB;gBAC3C,aAAa,EAAE,oBAAoB,CAAC,kBAAkB;gBACtD,cAAc,EAAE,KAAK;aACtB,CAAC;YACF,UAAU;YACV,mBAAmB,EAAE,YAAY;SAClC;KACF,CAAC,CAAC;IAEH,MAAM,eAAe,GAAG,MAAM,wBAAwB,CAAC;QACrD,OAAO;QACP,OAAO,EAAE,aAAa;QACtB,mBAAmB,EAAE,aAAa,CAAC,SAAS;QAC5C,8DAA8D;QAC9D,sEAAsE;QACtE,SAAS,EAAE,UAAU,CAAC,MAAM,GAAG,CAAC;KACjC,CAAC,CAAC;IAEH,MAAM,YAAY,GAAG,eAAe,CAAC,UAAU,CAAC,IAAI,CAClD,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,aAAa,CAClC,CAAC;IAEF,IAAI,CAAC,YAAY,EAAE,CAAC;QAClB,2BAA2B;QAC3B,MAAM,IAAI,KAAK,CACb,gGAAgG,CACjG,CAAC;IACJ,CAAC;IAED,OAAO;QACL,YAAY;QACZ,SAAS,EAAE,YAAY,CAAC,SAAS;QACjC,mBAAmB,EAAE,aAAa,CAAC,SAAS;KAC7C,CAAC;AACJ,CAAC","sourcesContent":["import {\n  AccountNotFoundError,\n  IncompatibleClientError,\n  SmartAccountWithSignerRequiredError,\n  isSmartAccountClient,\n  isSmartAccountWithSigner,\n  type SmartContractAccount,\n} from \"@aa-sdk/core\";\nimport { type Chain, type Client, type Transport } from \"viem\";\nimport { MultisigMissingSignatureError } from \"../../../errors.js\";\nimport {\n  type SignMultisigUserOperationParams,\n  type SignMultisigUserOperationResult,\n} from \"../types.js\";\nimport { combineSignatures, splitAggregatedSignature } from \"../utils/index.js\";\n\nexport async function signMultisigUserOperation<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends SmartContractAccount | undefined =\n    | SmartContractAccount\n    | undefined\n>(\n  client: Client<TTransport, TChain, TAccount>,\n  params: SignMultisigUserOperationParams<TAccount>\n): Promise<SignMultisigUserOperationResult> {\n  const { account = client.account, signatures, userOperationRequest } = params;\n\n  if (!account) {\n    throw new AccountNotFoundError();\n  }\n\n  if (!isSmartAccountClient(client)) {\n    throw new IncompatibleClientError(\n      \"SmartAccountClient\",\n      \"signMultisigUserOperation\",\n      client\n    );\n  }\n\n  if (!isSmartAccountWithSigner(account)) {\n    throw new SmartAccountWithSignerRequiredError();\n  }\n\n  if (!signatures.length) {\n    throw new MultisigMissingSignatureError();\n  }\n\n  const signerAddress = await account.getSigner().getAddress();\n\n  const signedRequest = await client.signUserOperation({\n    account,\n    uoStruct: userOperationRequest,\n    context: {\n      aggregatedSignature: combineSignatures({\n        signatures,\n        upperLimitMaxFeePerGas: userOperationRequest.maxFeePerGas,\n        upperLimitMaxPriorityFeePerGas:\n          userOperationRequest.maxPriorityFeePerGas,\n        upperLimitPvg: userOperationRequest.preVerificationGas,\n        usingMaxValues: false,\n      }),\n      signatures,\n      userOpSignatureType: \"UPPERLIMIT\",\n    },\n  });\n\n  const splitSignatures = await splitAggregatedSignature({\n    account,\n    request: signedRequest,\n    aggregatedSignature: signedRequest.signature,\n    // split works on the assumption that we have t - 1 signatures\n    // we have signatures.length + 1 signatures now, so we need sl + 1 + 1\n    threshold: signatures.length + 2,\n  });\n\n  const signatureObj = splitSignatures.signatures.find(\n    (x) => x.signer === signerAddress\n  );\n\n  if (!signatureObj) {\n    // TODO: strongly type this\n    throw new Error(\n      \"INTERNAL ERROR: signature not found in split signatures, this is an internal bug please report\"\n    );\n  }\n\n  return {\n    signatureObj,\n    signature: signatureObj.signature,\n    aggregatedSignature: signedRequest.signature,\n  };\n}\n"]}