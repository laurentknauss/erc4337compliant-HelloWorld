{"version":3,"file":"proposeUserOperation.js","sourceRoot":"","sources":["../../../../../../../src/msca/plugins/multisig/actions/proposeUserOperation.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,oBAAoB,EACpB,uBAAuB,EACvB,oBAAoB,EACpB,wBAAwB,EACxB,mCAAmC,GAKpC,MAAM,cAAc,CAAC;AACtB,OAAO,EAA2C,MAAM,MAAM,CAAC;AAC/D,OAAO,EAAmC,MAAM,aAAa,CAAC;AAC9D,OAAO,EAAE,wBAAwB,EAAE,MAAM,sCAAsC,CAAC;AAEhF,MAAM,CAAC,KAAK,UAAU,oBAAoB,CAQxC,MAA4C,EAC5C,EACE,EAAE,EACF,OAAO,GAAG,MAAM,CAAC,OAAO,EACxB,SAAS,EAAE,UAAU,GAC4B;IAEnD,qEAAqE;IACrE,MAAM,SAAS,GAAG;QAChB,YAAY,EAAE,EAAE,UAAU,EAAE,CAAC,EAAE;QAC/B,oBAAoB,EAAE,EAAE,UAAU,EAAE,CAAC,EAAE;QACvC,kBAAkB,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE;QACxC,GAAG,UAAU;KACgC,CAAC;IAEhD,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,MAAM,IAAI,oBAAoB,EAAE,CAAC;IACnC,CAAC;IAED,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,EAAE,CAAC;QAClC,MAAM,IAAI,uBAAuB,CAC/B,oBAAoB,EACpB,sBAAsB,EACtB,MAAM,CACP,CAAC;IACJ,CAAC;IAED,IAAI,CAAC,wBAAwB,CAAC,OAAO,CAAC,EAAE,CAAC;QACvC,MAAM,IAAI,mCAAmC,EAAE,CAAC;IAClD,CAAC;IAED,MAAM,OAAO,GAAG,MAAM,MAAM,CAAC,kBAAkB,CAAC;QAC9C,OAAO;QACP,EAAE;QACF,SAAS;KACV,CAAC,CAAC;IAEH,MAAM,OAAO,GAAG,MAAM,MAAM,CAAC,iBAAiB,CAAC;QAC7C,QAAQ,EAAE,OAAO;QACjB,OAAO;QACP,OAAO,EAAE;YACP,mBAAmB,EAAE,YAAY;SAClC;KACF,CAAC,CAAC;IAEH,MAAM,eAAe,GAAG,MAAM,wBAAwB,CAAC;QACrD,OAAO;QACP,mBAAmB,EAAE,OAAO,CAAC,SAAS;QACtC,OAAO;QACP,8DAA8D;QAC9D,SAAS,EAAE,CAAC;KACb,CAAC,CAAC;IAEH,OAAO;QACL,OAAO;QACP,YAAY,EAAE,eAAe,CAAC,UAAU,CAAC,CAAC,CAAC;QAC3C,mBAAmB,EAAE,OAAO,CAAC,SAAS;KACvC,CAAC;AACJ,CAAC","sourcesContent":["import {\n  AccountNotFoundError,\n  IncompatibleClientError,\n  isSmartAccountClient,\n  isSmartAccountWithSigner,\n  SmartAccountWithSignerRequiredError,\n  type GetEntryPointFromAccount,\n  type SendUserOperationParameters,\n  type SmartContractAccount,\n  type UserOperationOverrides,\n} from \"@aa-sdk/core\";\nimport { type Chain, type Client, type Transport } from \"viem\";\nimport { type ProposeUserOperationResult } from \"../types.js\";\nimport { splitAggregatedSignature } from \"../utils/splitAggregatedSignature.js\";\n\nexport async function proposeUserOperation<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends SmartContractAccount | undefined =\n    | SmartContractAccount\n    | undefined,\n  TEntryPointVersion extends GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>\n>(\n  client: Client<TTransport, TChain, TAccount>,\n  {\n    uo,\n    account = client.account,\n    overrides: overrides_,\n  }: SendUserOperationParameters<TAccount, undefined>\n): Promise<ProposeUserOperationResult> {\n  // these overrides allow us to set a high max fee and PVG upper bound\n  const overrides = {\n    maxFeePerGas: { multiplier: 3 },\n    maxPriorityFeePerGas: { multiplier: 2 },\n    preVerificationGas: { multiplier: 1000 },\n    ...overrides_,\n  } as UserOperationOverrides<TEntryPointVersion>;\n\n  if (!account) {\n    throw new AccountNotFoundError();\n  }\n\n  if (!isSmartAccountClient(client)) {\n    throw new IncompatibleClientError(\n      \"SmartAccountClient\",\n      \"proposeUserOperation\",\n      client\n    );\n  }\n\n  if (!isSmartAccountWithSigner(account)) {\n    throw new SmartAccountWithSignerRequiredError();\n  }\n\n  const builtUo = await client.buildUserOperation({\n    account,\n    uo,\n    overrides,\n  });\n\n  const request = await client.signUserOperation({\n    uoStruct: builtUo,\n    account,\n    context: {\n      userOpSignatureType: \"UPPERLIMIT\",\n    },\n  });\n\n  const splitSignatures = await splitAggregatedSignature({\n    request,\n    aggregatedSignature: request.signature,\n    account,\n    // split works on the assumption that we have t - 1 signatures\n    threshold: 2,\n  });\n\n  return {\n    request,\n    signatureObj: splitSignatures.signatures[0],\n    aggregatedSignature: request.signature,\n  };\n}\n"]}