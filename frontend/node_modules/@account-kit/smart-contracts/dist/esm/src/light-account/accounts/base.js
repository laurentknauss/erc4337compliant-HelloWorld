import { FailedToGetStorageSlotError, createBundlerClient, toSmartContractAccount, } from "@aa-sdk/core";
import { concat, encodeFunctionData, fromHex, hashMessage, hashTypedData, trim, } from "viem";
import { AccountVersionRegistry } from "../utils.js";
var SignatureType;
(function (SignatureType) {
    SignatureType["EOA"] = "0x00";
    SignatureType["CONTRACT"] = "0x01";
    SignatureType["CONTRACT_WITH_ADDR"] = "0x02";
})(SignatureType || (SignatureType = {}));
//#endregion CreateLightAccountBaseParams
export async function createLightAccountBase({ transport, chain, signer, abi, version, type, entryPoint, accountAddress, getAccountInitCode, }) {
    const client = createBundlerClient({
        transport,
        chain,
    });
    const encodeUpgradeToAndCall = async ({ upgradeToAddress, upgradeToInitData, }) => {
        const storage = await client.getStorageAt({
            address: accountAddress,
            // the slot at which impl addresses are stored by UUPS
            slot: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
        });
        if (storage == null) {
            throw new FailedToGetStorageSlotError("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc", "Proxy Implementation Address");
        }
        const implementationAddresses = Object.values(AccountVersionRegistry[type]).map((x) => x.addresses.overrides?.[chain.id]?.impl ?? x.addresses.default.impl);
        // only upgrade undeployed accounts (storage 0) or deployed light accounts, error otherwise
        if (fromHex(storage, "number") !== 0 &&
            !implementationAddresses.some((x) => x === trim(storage))) {
            throw new Error(`could not determine if smart account implementation is ${type} ${String(version)}`);
        }
        return encodeFunctionData({
            abi,
            functionName: "upgradeToAndCall",
            args: [upgradeToAddress, upgradeToInitData],
        });
    };
    const signWith1271Wrapper = async (hashedMessage, version) => {
        return signer.signTypedData({
            // EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)
            // https://github.com/alchemyplatform/light-account/blob/main/src/LightAccount.sol#L236
            domain: {
                chainId: Number(client.chain.id),
                name: type,
                verifyingContract: accountAddress,
                version,
            },
            types: {
                LightAccountMessage: [{ name: "message", type: "bytes" }],
            },
            message: {
                message: hashedMessage,
            },
            primaryType: "LightAccountMessage",
        });
    };
    const account = await toSmartContractAccount({
        transport,
        chain,
        entryPoint,
        accountAddress,
        source: type,
        getAccountInitCode,
        encodeExecute: async ({ target, data, value }) => {
            return encodeFunctionData({
                abi,
                functionName: "execute",
                args: [target, value ?? 0n, data],
            });
        },
        encodeBatchExecute: async (txs) => {
            const [targets, values, datas] = txs.reduce((accum, curr) => {
                accum[0].push(curr.target);
                accum[1].push(curr.value ?? 0n);
                accum[2].push(curr.data);
                return accum;
            }, [[], [], []]);
            return encodeFunctionData({
                abi,
                functionName: "executeBatch",
                args: [targets, values, datas],
            });
        },
        signUserOperationHash: async (uoHash) => {
            const signature = await signer.signMessage({ raw: uoHash });
            switch (version) {
                case "v2.0.0":
                    // TODO: handle case where signer is an SCA.
                    return concat([SignatureType.EOA, signature]);
                default:
                    return signature;
            }
        },
        async signMessage({ message }) {
            switch (version) {
                case "v1.0.1":
                    return signer.signMessage(message);
                case "v1.0.2":
                    throw new Error(`${type} ${String(version)} doesn't support 1271`);
                case "v1.1.0":
                    return signWith1271Wrapper(hashMessage(message), "1");
                case "v2.0.0":
                    const signature = await signWith1271Wrapper(hashMessage(message), "2");
                    // TODO: handle case where signer is an SCA.
                    return concat([SignatureType.EOA, signature]);
                default:
                    throw new Error(`Unknown version ${type} of ${String(version)}`);
            }
        },
        async signTypedData(params) {
            switch (version) {
                case "v1.0.1":
                    return signer.signTypedData(params);
                case "v1.0.2":
                    throw new Error(`Version ${String(version)} of LightAccount doesn't support 1271`);
                case "v1.1.0":
                    return signWith1271Wrapper(hashTypedData(params), "1");
                case "v2.0.0":
                    const signature = await signWith1271Wrapper(hashTypedData(params), "2");
                    // TODO: handle case where signer is an SCA.
                    return concat([SignatureType.EOA, signature]);
                default:
                    throw new Error(`Unknown version ${String(version)} of LightAccount`);
            }
        },
        getDummySignature: () => {
            const signature = "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
            switch (version) {
                case "v1.0.1":
                case "v1.0.2":
                case "v1.1.0":
                    return signature;
                case "v2.0.0":
                    return concat([SignatureType.EOA, signature]);
                default:
                    throw new Error(`Unknown version ${type} of ${String(version)}`);
            }
        },
        encodeUpgradeToAndCall,
    });
    return {
        ...account,
        source: type,
        getLightAccountVersion: () => version,
        getSigner: () => signer,
    };
}
//# sourceMappingURL=base.js.map