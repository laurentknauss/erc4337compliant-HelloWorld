{"version":3,"file":"alchemyTransport.js","sourceRoot":"","sources":["../../src/alchemyTransport.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ChainNotFoundError,\n  ConnectionConfigSchema,\n  split,\n  type ConnectionConfig,\n  type NoUndefined,\n} from \"@aa-sdk/core\";\nimport {\n  createTransport,\n  http,\n  type EIP1193RequestFn,\n  type HttpTransportConfig,\n  type PublicRpcSchema,\n  type Transport,\n  type TransportConfig,\n} from \"viem\";\nimport type { AlchemyRpcSchema } from \"./client/types.js\";\nimport { AlchemyChainSchema } from \"./schema.js\";\nimport { VERSION } from \"./version.js\";\n\ntype Never<T> = T extends object\n  ? {\n      [K in keyof T]?: never;\n    }\n  : never;\n\ntype SplitTransportConfig = {\n  alchemyConnection: ConnectionConfig;\n  nodeRpcUrl: string;\n};\n\nconst alchemyMethods = [\n  \"eth_sendUserOperation\",\n  \"eth_estimateUserOperationGas\",\n  \"eth_getUserOperationReceipt\",\n  \"eth_getUserOperationByHash\",\n  \"eth_supportedEntryPoints\",\n  \"rundler_maxPriorityFeePerGas\",\n  \"pm_getPaymasterData\",\n  \"pm_getPaymasterStubData\",\n];\n\nexport type AlchemyTransportConfig = (\n  | (ConnectionConfig & Never<SplitTransportConfig>)\n  | (SplitTransportConfig & Never<ConnectionConfig>)\n) & {\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig[\"retryCount\"] | undefined;\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig[\"retryDelay\"] | undefined;\n  fetchOptions?: NoUndefined<HttpTransportConfig[\"fetchOptions\"]>;\n};\n\ntype AlchemyTransportBase = Transport<\n  \"alchemy\",\n  {\n    alchemyRpcUrl: string;\n    fetchOptions?: AlchemyTransportConfig[\"fetchOptions\"];\n  },\n  EIP1193RequestFn<[...PublicRpcSchema, ...AlchemyRpcSchema]>\n>;\n\nexport type AlchemyTransport = AlchemyTransportBase & {\n  updateHeaders(newHeaders: HeadersInit): void;\n  config: AlchemyTransportConfig;\n};\n\n/**\n * Creates an Alchemy transport with the specified configuration options.\n * When sending all traffic to Alchemy, you must pass in one of rpcUrl, apiKey, or jwt.\n * If you want to send Bundler and Paymaster traffic to Alchemy and Node traffic to a different RPC, you must pass in alchemyConnection and nodeRpcUrl.\n *\n * @example\n * ### Basic Example\n * If the chain you're using is supported for both Bundler and Node RPCs, then you can do the following:\n * ```ts\n * import { alchemy } from \"@account-kit/infra\";\n *\n * const transport = alchemy({\n *  // NOTE: you can also pass in an rpcUrl or jwt here or rpcUrl and jwt\n *  apiKey: \"your-api-key\",\n * });\n * ```\n *\n * ### AA Only Chains\n * For AA-only chains, you need to specify the alchemyConnection and nodeRpcUrl since Alchemy only\n * handles the Bundler and Paymaster RPCs for these chains.\n * ```ts\n * import { alchemy } from \"@account-kit/infra\";\n *\n * const transport = alchemy({\n *  alchemyConnection: {\n *    apiKey: \"your-api-key\",\n *  },\n *  nodeRpcUrl: \"https://zora.rpc.url\",\n * });\n * ```\n *\n * @param {AlchemyTransportConfig} config The configuration object for the Alchemy transport.\n * @param {number} config.retryDelay Optional The delay between retries, in milliseconds.\n * @param {number} config.retryCount Optional The number of retry attempts.\n * @param {string} [config.alchemyConnection] Optional Alchemy connection configuration (if this is passed in, nodeRpcUrl is required).\n * @param {string} [config.fetchOptions] Optional fetch options for HTTP requests.\n * @param {string} [config.nodeRpcUrl] Optional RPC URL for node (if this is passed in, alchemyConnection is required).\n * @param {string} [config.rpcUrl] Optional RPC URL.\n * @param {string} [config.apiKey] Optional API key for Alchemy.\n * @param {string} [config.jwt] Optional JSON Web Token for authorization.\n * @returns {AlchemyTransport} The configured Alchemy transport object.\n */\nexport function alchemy(config: AlchemyTransportConfig): AlchemyTransport {\n  const { retryDelay, retryCount } = config;\n  // we create a copy here in case we create a split transport down below\n  // we don't want to add alchemy headers to 3rd party nodes\n  const fetchOptions = { ...config.fetchOptions };\n\n  const connectionConfig = ConnectionConfigSchema.parse(\n    config.alchemyConnection ?? config\n  );\n\n  const headersAsObject = convertHeadersToObject(fetchOptions.headers);\n\n  // TODO: we probably should just log these headers during telemetry logging instead of doing this mutable header stuff\n  fetchOptions.headers = {\n    ...headersAsObject,\n    \"Alchemy-AA-Sdk-Version\": VERSION,\n  };\n\n  if (connectionConfig.jwt != null) {\n    fetchOptions.headers = {\n      ...fetchOptions.headers,\n      Authorization: `Bearer ${connectionConfig.jwt}`,\n    };\n  }\n\n  const transport: AlchemyTransportBase = (opts) => {\n    const { chain: chain_ } = opts;\n    if (!chain_) {\n      throw new ChainNotFoundError();\n    }\n    const chain = AlchemyChainSchema.parse(chain_);\n\n    const rpcUrl =\n      connectionConfig.rpcUrl == null\n        ? `${chain.rpcUrls.alchemy.http[0]}/${connectionConfig.apiKey ?? \"\"}`\n        : connectionConfig.rpcUrl;\n\n    const innerTransport = (() => {\n      if (config.alchemyConnection && config.nodeRpcUrl) {\n        return split({\n          overrides: [\n            {\n              methods: alchemyMethods,\n              transport: http(rpcUrl, { fetchOptions }),\n            },\n          ],\n          fallback: http(config.nodeRpcUrl, {\n            fetchOptions: config.fetchOptions,\n          }),\n        });\n      }\n\n      return http(rpcUrl, { fetchOptions });\n    })();\n\n    return createTransport(\n      {\n        key: \"alchemy\",\n        name: \"Alchemy Transport\",\n        request: innerTransport(opts).request,\n        retryCount: retryCount ?? opts?.retryCount,\n        retryDelay,\n        type: \"alchemy\",\n      },\n      { alchemyRpcUrl: rpcUrl, fetchOptions }\n    );\n  };\n\n  return Object.assign(transport, {\n    updateHeaders(newHeaders_: HeadersInit) {\n      const newHeaders = convertHeadersToObject(newHeaders_);\n\n      fetchOptions.headers = {\n        ...fetchOptions.headers,\n        ...newHeaders,\n      };\n    },\n    config,\n  });\n}\n\nconst convertHeadersToObject = (\n  headers?: HeadersInit\n): Record<string, string> => {\n  if (!headers) {\n    return {};\n  }\n\n  if (headers instanceof Headers) {\n    const headersObject = {} as Record<string, string>;\n    headers.forEach((value, key) => {\n      headersObject[key] = value;\n    });\n    return headersObject;\n  }\n\n  if (Array.isArray(headers)) {\n    return headers.reduce((acc, header) => {\n      acc[header[0]] = header[1];\n      return acc;\n    }, {} as Record<string, string>);\n  }\n\n  return headers;\n};\n"]}